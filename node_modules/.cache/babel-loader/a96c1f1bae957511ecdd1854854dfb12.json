{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useEffect, useContext } from 'react';\nimport { UserContext } from '../userContext';\nimport '../components/styles.css';\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction SudokuBoard() {\n  _s();\n\n  const {\n    solvedBoard,\n    difficultyLevel,\n    SetSolvedBoard,\n    SetCurrentBoard\n  } = useContext(UserContext);\n  let startingBoard = [];\n\n  function generateBoard() {\n    const matrix = Array(9).fill().map(() => Array(9).fill(0)); //  let nextZero = FindZero(board)\n    // 3 steps to randomly assign 3x3 squares of numbers\n    // Top left 3x3\n\n    let rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    shuffle(rndNumbers);\n\n    for (let i = 0; i < 3; i++) {\n      for (let k = 0; k < 3; k++) {\n        matrix[i][k] = rndNumbers[0];\n        rndNumbers.splice(0, 1);\n      }\n    } // re initialize rndNumbers and shuffle to add to middle 3x3\n\n\n    rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    shuffle(rndNumbers);\n\n    for (let i = 3; i < 6; i++) {\n      for (let k = 3; k < 6; k++) {\n        matrix[i][k] = rndNumbers[0];\n        rndNumbers.shift();\n      }\n    } // shuffle and arrange the last 3x3 ( bottom right square)\n    // re initialize rndNumbers\n\n\n    rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    shuffle(rndNumbers);\n\n    for (let i = 6; i < 9; i++) {\n      for (let k = 6; k < 9; k++) {\n        matrix[i][k] = rndNumbers[0];\n        rndNumbers.shift();\n      }\n    }\n\n    startingBoard = [...matrix];\n    SolveBoard(startingBoard);\n  }\n\n  function shuffle(numberArray) {\n    // Fisher Yates Shuffle //\n    let currentIndex = numberArray.length,\n        randomIndex; // While there remain elements to shuffle.\n\n    while (currentIndex !== 0) {\n      // Pick a remaining element.\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex--; // And swap it with the current element.\n\n      [numberArray[currentIndex], numberArray[randomIndex]] = [numberArray[randomIndex], numberArray[currentIndex]];\n    } // Used like so\n    //console.log(numberArray);\n\n\n    return numberArray;\n  }\n\n  function FindZero(board) {\n    //finds next 0 on board and returns its location//\n    let zeroPlacement = [];\n\n    for (let i = 0; i < board.length; i++) {\n      for (let j = 0; j < board[i].length; j++) {\n        if (board[i][j] === 0) {\n          zeroPlacement.push(i);\n          zeroPlacement.push(j);\n          return zeroPlacement;\n        }\n\n        if (zeroPlacement.length !== 0) {\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  function IsValidPlacement(row, col, value) {\n    // 3 if statements, nr. 1 checks for horizontal duplicates. Nr 2 = Vertical duplicates. Nr 3 = 3x3 block duplicated\n    for (let i = 0; i < startingBoard.length; i++) {\n      if (startingBoard[row][i] === value) {\n        return false;\n      }\n\n      if (startingBoard[i][col] === value) {\n        return false;\n      }\n\n      if (startingBoard[Math.floor(row - row % 3 + i / 3)][Math.floor(col - col % 3 + i % 3)] === value) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function SolveBoard(boardToSolve) {\n    let solved = startingBoard;\n    let nextZero = [];\n    nextZero = FindZero(solved); // Base Case\n    // uses find_zero to locate 0, if there are no more 0, job done, return board\n\n    if (nextZero === null) {\n      return solved;\n    } // Recursive Case\n    else {\n      let row = nextZero[0];\n      let col = nextZero[1];\n\n      for (let i = 1; i < 10; i++) {\n        if (IsValidPlacement(row, col, i) === true) {\n          solved[row][col] = i;\n          let updatedBoard = [];\n          updatedBoard = SolveBoard(updatedBoard); // if there is a solution, return the solution\n\n          if (updatedBoard != null) {\n            solved = [...updatedBoard];\n            SetSolvedBoard([...solved]);\n            startingBoard = [];\n            return updatedBoard;\n          } else {\n            solved[row][col] = 0;\n          }\n        }\n      }\n    }\n  }\n\n  function boardLevel() {\n    //let tempBoard = Array.from(solvedBoard);\n    let newBoard = JSON.parse(JSON.stringify(solvedBoard));\n\n    if (difficultyLevel === 1) {\n      for (let i = 0; i < 44; i++) {\n        const randomCol = Math.floor(Math.random() * newBoard.length);\n        const randomRow = Math.floor(Math.random() * newBoard.length);\n\n        try {\n          if (newBoard[randomCol][randomRow] !== 0) {\n            newBoard[randomCol][randomRow] = 0;\n          } else {\n            i--;\n          }\n        } catch (error) {//console.log(error);\n        }\n      }\n    } else if (difficultyLevel === 2) {\n      for (let i = 0; i < 49; i++) {\n        const randomCol = Math.floor(Math.random() * newBoard.length);\n        const randomRow = Math.floor(Math.random() * newBoard.length);\n\n        try {\n          if (newBoard[randomCol][randomRow] !== 0) {\n            newBoard[randomCol][randomRow] = 0;\n          } else {\n            i--;\n          }\n        } catch (error) {//console.log(error);\n        }\n      }\n    } else if (difficultyLevel === 3) {\n      for (let i = 0; i < 54; i++) {\n        const randomCol = Math.floor(Math.random() * newBoard.length);\n        const randomRow = Math.floor(Math.random() * newBoard.length);\n\n        try {\n          if (newBoard[randomCol][randomRow] !== 0) {\n            newBoard[randomCol][randomRow] = 0;\n          } else {\n            i--;\n          }\n        } catch (error) {//console.log(error);\n        }\n      }\n    }\n\n    SetCurrentBoard([...newBoard]);\n  }\n\n  useEffect(() => {\n    generateBoard();\n  });\n  useEffect(() => {\n    boardLevel();\n  }, [solvedBoard]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n}\n\n_s(SudokuBoard, \"cmcAYsikeXwbZtuxANqBgYwrRdE=\");\n\n_c = SudokuBoard;\nexport default SudokuBoard;\n\nvar _c;\n\n$RefreshReg$(_c, \"SudokuBoard\");","map":{"version":3,"names":["React","useEffect","useContext","UserContext","SudokuBoard","solvedBoard","difficultyLevel","SetSolvedBoard","SetCurrentBoard","startingBoard","generateBoard","matrix","Array","fill","map","rndNumbers","shuffle","i","k","splice","shift","SolveBoard","numberArray","currentIndex","length","randomIndex","Math","floor","random","FindZero","board","zeroPlacement","j","push","IsValidPlacement","row","col","value","boardToSolve","solved","nextZero","updatedBoard","boardLevel","newBoard","JSON","parse","stringify","randomCol","randomRow","error"],"sources":["C:/Users/User/Documents/devProjects/sudokuManiac/sudoku_app/src/components/SudokuBrain.js"],"sourcesContent":["import React, { useEffect, useContext } from 'react';\r\nimport { UserContext } from '../userContext';\r\nimport '../components/styles.css';\r\n\r\nfunction SudokuBoard() {\r\n  const { solvedBoard, difficultyLevel, SetSolvedBoard, SetCurrentBoard } =\r\n    useContext(UserContext);\r\n  let startingBoard = [];\r\n\r\n  function generateBoard() {\r\n    const matrix = Array(9)\r\n      .fill()\r\n      .map(() => Array(9).fill(0));\r\n\r\n    //  let nextZero = FindZero(board)\r\n    // 3 steps to randomly assign 3x3 squares of numbers\r\n    // Top left 3x3\r\n    let rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n    shuffle(rndNumbers);\r\n    for (let i = 0; i < 3; i++) {\r\n      for (let k = 0; k < 3; k++) {\r\n        matrix[i][k] = rndNumbers[0];\r\n        rndNumbers.splice(0, 1);\r\n      }\r\n    }\r\n    // re initialize rndNumbers and shuffle to add to middle 3x3\r\n    rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n    shuffle(rndNumbers);\r\n    for (let i = 3; i < 6; i++) {\r\n      for (let k = 3; k < 6; k++) {\r\n        matrix[i][k] = rndNumbers[0];\r\n        rndNumbers.shift();\r\n      }\r\n    }\r\n\r\n    // shuffle and arrange the last 3x3 ( bottom right square)\r\n    // re initialize rndNumbers\r\n    rndNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\n    shuffle(rndNumbers);\r\n    for (let i = 6; i < 9; i++) {\r\n      for (let k = 6; k < 9; k++) {\r\n        matrix[i][k] = rndNumbers[0];\r\n        rndNumbers.shift();\r\n      }\r\n    }\r\n\r\n    startingBoard = [...matrix];\r\n\r\n    SolveBoard(startingBoard);\r\n  }\r\n\r\n  function shuffle(numberArray) {\r\n    // Fisher Yates Shuffle //\r\n\r\n    let currentIndex = numberArray.length,\r\n      randomIndex;\r\n\r\n    // While there remain elements to shuffle.\r\n    while (currentIndex !== 0) {\r\n      // Pick a remaining element.\r\n      randomIndex = Math.floor(Math.random() * currentIndex);\r\n      currentIndex--;\r\n\r\n      // And swap it with the current element.\r\n      [numberArray[currentIndex], numberArray[randomIndex]] = [\r\n        numberArray[randomIndex],\r\n        numberArray[currentIndex],\r\n      ];\r\n    }\r\n    // Used like so\r\n    //console.log(numberArray);\r\n    return numberArray;\r\n  }\r\n\r\n  function FindZero(board) {\r\n    //finds next 0 on board and returns its location//\r\n    let zeroPlacement = [];\r\n    for (let i = 0; i < board.length; i++) {\r\n      for (let j = 0; j < board[i].length; j++) {\r\n        if (board[i][j] === 0) {\r\n          zeroPlacement.push(i);\r\n          zeroPlacement.push(j);\r\n          return zeroPlacement;\r\n        }\r\n        if (zeroPlacement.length !== 0) {\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  function IsValidPlacement(row, col, value) {\r\n    // 3 if statements, nr. 1 checks for horizontal duplicates. Nr 2 = Vertical duplicates. Nr 3 = 3x3 block duplicated\r\n    for (let i = 0; i < startingBoard.length; i++) {\r\n      if (startingBoard[row][i] === value) {\r\n        return false;\r\n      }\r\n      if (startingBoard[i][col] === value) {\r\n        return false;\r\n      }\r\n      if (\r\n        startingBoard[Math.floor(row - (row % 3) + i / 3)][\r\n          Math.floor(col - (col % 3) + (i % 3))\r\n        ] === value\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function SolveBoard(boardToSolve) {\r\n    let solved = startingBoard;\r\n\r\n    let nextZero = [];\r\n    nextZero = FindZero(solved);\r\n\r\n    // Base Case\r\n    // uses find_zero to locate 0, if there are no more 0, job done, return board\r\n    if (nextZero === null) {\r\n      return solved;\r\n    }\r\n    // Recursive Case\r\n    else {\r\n      let row = nextZero[0];\r\n      let col = nextZero[1];\r\n\r\n      for (let i = 1; i < 10; i++) {\r\n        if (IsValidPlacement(row, col, i) === true) {\r\n          solved[row][col] = i;\r\n          let updatedBoard = [];\r\n          updatedBoard = SolveBoard(updatedBoard);\r\n\r\n          // if there is a solution, return the solution\r\n          if (updatedBoard != null) {\r\n            solved = [...updatedBoard];\r\n\r\n            SetSolvedBoard([...solved]);\r\n            startingBoard = [];\r\n            return updatedBoard;\r\n          } else {\r\n            solved[row][col] = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function boardLevel() {\r\n    //let tempBoard = Array.from(solvedBoard);\r\n    let newBoard = JSON.parse(JSON.stringify(solvedBoard));\r\n\r\n    if (difficultyLevel === 1) {\r\n      for (let i = 0; i < 44; i++) {\r\n        const randomCol = Math.floor(Math.random() * newBoard.length);\r\n        const randomRow = Math.floor(Math.random() * newBoard.length);\r\n        try {\r\n          if (newBoard[randomCol][randomRow] !== 0) {\r\n            newBoard[randomCol][randomRow] = 0;\r\n          } else {\r\n            i--;\r\n          }\r\n        } catch (error) {\r\n          //console.log(error);\r\n        }\r\n      }\r\n    } else if (difficultyLevel === 2) {\r\n      for (let i = 0; i < 49; i++) {\r\n        const randomCol = Math.floor(Math.random() * newBoard.length);\r\n        const randomRow = Math.floor(Math.random() * newBoard.length);\r\n\r\n        try {\r\n          if (newBoard[randomCol][randomRow] !== 0) {\r\n            newBoard[randomCol][randomRow] = 0;\r\n          } else {\r\n            i--;\r\n          }\r\n        } catch (error) {\r\n          //console.log(error);\r\n        }\r\n      }\r\n    } else if (difficultyLevel === 3) {\r\n      for (let i = 0; i < 54; i++) {\r\n        const randomCol = Math.floor(Math.random() * newBoard.length);\r\n        const randomRow = Math.floor(Math.random() * newBoard.length);\r\n\r\n        try {\r\n          if (newBoard[randomCol][randomRow] !== 0) {\r\n            newBoard[randomCol][randomRow] = 0;\r\n          } else {\r\n            i--;\r\n          }\r\n        } catch (error) {\r\n          //console.log(error);\r\n        }\r\n      }\r\n    }\r\n\r\n    SetCurrentBoard([...newBoard]);\r\n  }\r\n  \r\n  useEffect(() => {\r\n    generateBoard();\r\n  }, );\r\n\r\n  useEffect(() => {\r\n    boardLevel();\r\n  }, [solvedBoard]);\r\n  \r\n\r\n  return <></>;\r\n}\r\nexport default SudokuBoard;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}